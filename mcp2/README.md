# Bare Minimum MCP Server

A minimal MCP (Model Context Protocol) server with 2 tools to demonstrate AI-to-code entry points.

## What Claude Sees

When connected to Claude Desktop, this server appears as:

**Server Name:** "Demo MCP"  
**Description:** "Echo server tools for basic operations like adding numbers and getting demo information"

**Available Tools:**
- `add_numbers` - "Add two numbers together."
- `get_info` - "Get MCP demo information."

## Installation

### Prerequisites
```bash
# Install FastMCP
pip install fastmcp
```

### Download and Run
```bash
# Save the code as server.py, then:
python3 server.py
```

## Claude Desktop Configuration

Add this to your Claude Desktop config file:

**macOS:** `~/Library/Application Support/Claude/claude_desktop_config.json`  
**Windows:** `%APPDATA%/Claude/claude_desktop_config.json`

```json
{
  "mcpServers": {
    "demo-mcp": {
      "command": "python3",
      "args": ["/full/path/to/your/server.py"],
      "env": {}
    }
  }
}
```

Replace `/full/path/to/your/server.py` with the actual path to your server file.

## HTTP Endpoint (Optional)

To run as HTTP server instead of stdio:

```python
# Modify the last line in server.py to:
if __name__ == "__main__":
    mcp.run(transport="http", host="127.0.0.1", port=8000)
```

Then access via: `http://127.0.0.1:8000/mcp`

## Code Mapping - What Claude Sees vs. Code

### 1. Server Name
**Claude sees:** "Demo MCP"  
**Code source:** `FastMCP("Demo MCP")` - first parameter

### 2. Server Description
**Claude sees:** "Echo server tools for basic operations like adding numbers and getting demo information"  
**Code source:** Auto-generated by FastMCP based on tool names and docstrings

### 3. Tool Names
**Claude sees:** `add_numbers`, `get_info`  
**Code source:** Function names with `@mcp.tool` decorator
```python
@mcp.tool
def add_numbers(...):  # ← Function name becomes tool name
```

### 4. Tool Descriptions
**Claude sees:** "Add two numbers together." and "Get MCP demo information."  
**Code source:** Function docstrings (first line)
```python
def add_numbers(a: float, b: float) -> dict:
    """Add two numbers together."""  # ← This becomes tool description
```

### 5. Tool Parameters
**Claude sees:** Parameters `a` and `b` (both floats) for `add_numbers`  
**Code source:** Function signature type hints
```python
def add_numbers(a: float, b: float):  # ← Claude reads these parameters
    #              ↑        ↑
    #        parameter   parameter
    #          name        type
```

### 6. Tool Results
**Claude sees:** JSON response like `{"result": 8}`  
**Code source:** Function return value
```python
return {"result": a + b}  # ← This JSON goes to Claude
```

## JSON-RPC Format & Response Mapping

MCP uses JSON-RPC 2.0 as its communication protocol. Here's how the test script responses map directly to your Python code:

### 1. Initialize Response Mapping

**Test Script Response:**
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2024-11-05",
    "capabilities": {
      "tools": {"listChanged": true}
    },
    "serverInfo": {
      "name": "HTTP Demo MCP",        // ← From your code
      "version": "1.12.2"
    }
  }
}
```

**Code Source:**
```python
mcp = FastMCP("HTTP Demo MCP")  # ← Server name appears in response
```

### 2. Tools List Response Mapping

**JSON-RPC Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/list"
}
```

**Expected Response (what FastMCP generates from your code):**
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "tools": [
      {
        "name": "add_numbers",                    // ← Function name
        "description": "Add two numbers together.", // ← Docstring
        "inputSchema": {
          "type": "object",
          "properties": {
            "a": {"type": "number"},              // ← Parameter 'a: float'
            "b": {"type": "number"}               // ← Parameter 'b: float'
          },
          "required": ["a", "b"]                 // ← Both required
        }
      },
      {
        "name": "get_info",                      // ← Function name
        "description": "Get MCP demo information.", // ← Docstring
        "inputSchema": {
          "type": "object",
          "properties": {},                      // ← No parameters
          "required": []
        }
      }
    ]
  }
}
```

**Code Source:**
```python
@mcp.tool
def add_numbers(a: float, b: float) -> dict:  # ← Name, params, types
    """Add two numbers together."""           # ← Description
    return {"result": a + b}

@mcp.tool  
def get_info() -> dict:                       # ← Name, no params
    """Get MCP demo information."""           # ← Description
    return {...}
```

### 3. Tool Call Response Mapping

**JSON-RPC Request:**
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tools/call",
  "params": {
    "name": "add_numbers",        // ← Calls your Python function
    "arguments": {
      "a": 42,                    // ← Function parameter
      "b": 58                     // ← Function parameter
    }
  }
}
```

**Response (from your function execution):**
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"result\": 100, \"operation\": \"42 + 58 = 100\"}"
      }
    ]
  }
}
```

**Code Execution:**
```python
def add_numbers(a: float, b: float) -> dict:
    return {
        "result": a + b,                      # ← 42 + 58 = 100
        "operation": f"{a} + {b} = {a + b}"   # ← "42 + 58 = 100"
    }
    # This dict becomes the JSON response content
```

### 4. Complete Code-to-Response Flow

**Your Python Code:**
```python
from fastmcp import FastMCP

mcp = FastMCP("HTTP Demo MCP")               # ← Server name in responses

@mcp.tool
def add_numbers(a: float, b: float) -> dict: # ← Tool schema generation
    """Add two numbers together."""          # ← Tool description
    return {"result": a + b}                 # ← Tool response content

if __name__ == "__main__":
    mcp.run(transport="streamable-http")     # ← HTTP JSON-RPC server
```

**Generates This API:**

1. **Server Info**: Name from `FastMCP("HTTP Demo MCP")`
2. **Tool Schema**: Generated from function signature and docstring
3. **Tool Execution**: Your function runs, return value becomes JSON response
4. **Transport**: HTTP server handles JSON-RPC protocol automatically

### 5. JSON-RPC Structure Elements

Every MCP message follows JSON-RPC 2.0 format:

```json
{
  "jsonrpc": "2.0",        // Protocol version (always "2.0")
  "id": 123,               // Request ID (for matching responses)
  "method": "tools/call",  // MCP method being called
  "params": {...}          // Method parameters (optional)
}
```

**Response Format:**
```json
{
  "jsonrpc": "2.0",     // Same protocol version
  "id": 123,            // Matches request ID
  "result": {...}       // Success result OR
  "error": {...}        // Error details (if failed)
}
```

## Streamable HTTP Transport

### What "Streamable HTTP" Means

**Streamable HTTP** is MCP's modern transport protocol that combines the best of HTTP and streaming:

1. **HTTP Foundation**: Standard HTTP POST requests with JSON-RPC payloads
2. **Streaming Capability**: Server can send multi-part responses or real-time updates
3. **Bidirectional**: Server can send notifications back to client during long operations
4. **Single Endpoint**: One URL handles all MCP communication (unlike old SSE which needed two)

### How It Works

```
Client Request  →  HTTP POST /mcp/  →  Server
Client         ←  HTTP Response    ←  Server (can be streaming)
```

**Example Flow:**
1. **Simple Request**: Client sends JSON-RPC, gets immediate JSON response
2. **Streaming Request**: Client sends JSON-RPC, server streams multiple responses
3. **Notifications**: Server can send updates during long-running operations

### Transport Comparison

| Feature | Streamable HTTP | Old SSE | WebSocket |
|---------|----------------|---------|-----------|
| **Setup** | Single POST endpoint | Two endpoints needed | Connection upgrade |
| **Streaming** | ✅ Optional | ✅ Always | ✅ Always |
| **HTTP Compatibility** | ✅ Standard HTTP | ⚠️ Complex | ❌ Different protocol |
| **Firewall Friendly** | ✅ Yes | ✅ Yes | ⚠️ Sometimes blocked |
| **Caching/Proxies** | ✅ Works well | ⚠️ Limited | ❌ Doesn't work |

## Session Management & IDs

### The ID System

JSON-RPC uses **request IDs** to match responses to requests:

```json
// Request
{"jsonrpc": "2.0", "id": 123, "method": "tools/call", ...}

// Response  
{"jsonrpc": "2.0", "id": 123, "result": {...}}
```

**ID Purposes:**
- **Match responses** to requests in async communication
- **Handle multiple** concurrent requests
- **Detect duplicates** and lost messages

### Session Management

MCP sessions work differently than web sessions:

#### 1. **HTTP Cookies (Limited)**
```bash
# Save session cookie
curl -c cookies.txt http://server/mcp/

# Use session cookie  
curl -b cookies.txt http://server/mcp/
```

**Problem**: MCP sessions are more complex than simple cookies can handle.

#### 2. **Connection-Based Sessions**
```
Client connects → Initialize → Session established → Multiple requests → Disconnect
```

**How it works:**
- **Initialize** creates server-side session state
- **Session ID** tracked internally (not in cookies)
- **Subsequent requests** must reference the same session
- **Connection state** maintained for the conversation

#### 3. **Why Our Demo Has Session Issues**

```bash
# Each curl command = separate HTTP connection
curl POST /mcp/ '{"method": "initialize"}'  # Creates session A
curl POST /mcp/ '{"method": "tools/list"}'  # New connection, no session!
```

**In Production:**
- **Claude Desktop**: Maintains persistent connection via stdio
- **MCP Clients**: Handle session management automatically
- **Long-lived connections**: Keep session state alive

### Session State Management

```python
# What happens in FastMCP (simplified)
sessions = {}

def initialize(client_id, params):
    session_id = generate_session_id()
    sessions[session_id] = {
        'client_info': params['clientInfo'],
        'capabilities': params['capabilities'],
        'tools': discover_tools()
    }
    return session_id

def tools_list(session_id):
    if session_id not in sessions:
        raise "Missing session ID"
    return sessions[session_id]['tools']
```

### Why This Matters for AI Integration

**MCP sessions enable:**
- **Stateful conversations**: Server remembers context
- **Tool discovery**: One-time setup, multiple tool calls
- **Security**: Session-based access control
- **Performance**: Avoid re-initialization overhead

**Production MCP clients (like Claude Desktop) handle this automatically**, which is why the same Python code works seamlessly there.

## Testing

### Test with Claude Desktop
1. Configure Claude Desktop (see above)
2. Restart Claude Desktop
3. Try these prompts:
    - "Add 5 and 3" (may not use tool - too simple)
    - "Use add_numbers to calculate 10 + 15" (explicit tool usage)
    - "Calculate 456 + 789 accurately" (should trigger tool)
    - "Get demo information"

### Test via HTTP (JSON-RPC)

**1. Start HTTP server:**
```python
# Modify server.py:
if __name__ == "__main__":
    mcp.run(transport="http", host="127.0.0.1", port=8000)
```

**2. Initialize connection:**
```bash
curl -X POST http://127.0.0.1:8000/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "initialize",
    "params": {
      "protocolVersion": "2024-11-05",
      "capabilities": {},
      "clientInfo": {"name": "curl", "version": "1.0"}
    }
  }'
```

**3. List available tools:**
```bash
curl -X POST http://127.0.0.1:8000/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/list"
  }'
```

**4. Call a tool:**
```bash
curl -X POST http://127.0.0.1:8000/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "add_numbers",
      "arguments": {"a": 5, "b": 3}
    }
  }'
```

### Understanding the Flow

**Claude Desktop → JSON-RPC → Your Python Code:**

1. **Claude thinks:** "User wants to add numbers"
2. **Claude sends JSON-RPC:** `{"method": "tools/call", "params": {"name": "add_numbers", "arguments": {"a": 5, "b": 3}}}`
3. **FastMCP receives:** JSON-RPC message over stdio/HTTP
4. **FastMCP calls:** `add_numbers(a=5, b=3)` - your Python function
5. **Your function returns:** `{"result": 8}`
6. **FastMCP sends JSON-RPC response:** `{"result": {"content": [{"type": "text", "text": "{\"result\": 8}"}]}}`
7. **Claude receives:** The result and presents it to user

## Understanding MCP Entry Points

**The Flow:**
1. **User asks Claude:** "Add 5 and 3"
2. **Claude calls MCP tool:** `add_numbers(a=5, b=3)`
3. **Python function executes:** `return {"result": 5 + 3}`
4. **Claude gets result:** `{"result": 8}`
5. **Claude responds to user:** "The result is 8"

**Key Insight:** MCP creates bridges between AI requests and your Python functions. The function signature and docstring determine what Claude sees and how it can use your code.

## Troubleshooting

**Claude doesn't see the server:**
- Check the config file path and JSON syntax
- Ensure the server file path is absolute
- Restart Claude Desktop after config changes

**Tools not working:**
- Check server is running without errors
- Verify function signatures match what Claude is sending
- Look at server console output for debugging

**Import errors:**
- Install FastMCP: `pip install fastmcp`
- Check Python version (3.8+ recommended)
